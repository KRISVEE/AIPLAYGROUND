<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Crypto Network Simulator 2025</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Three.js OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- 
        README & TEST CHECKLIST
        =======================
        
        HOW TO RUN:
        1. Save this file as index.html.
        2. Open in Chrome/Edge/Firefox.
        3. Click "Start Network" to begin.
        
        KEYBOARD CONTROLS:
        - Space: Pause/Resume
        - 1, 2, 3, 4: Set Speed (x1, x10, x100, x1000)
        - V: Cycle View (Lobby -> Network -> Farm -> Block Explorer)
        
        TEST CHECKLIST:
        [ ] UI renders with Dark Mode and 3D Canvas.
        [ ] Simulation starts, "Block Height" increases.
        [ ] Network View shows nodes flashing on block propagation.
        [ ] Leaderboard updates dynamically.
        [ ] Charts populate after ~10 seconds.
        [ ] CSV Export works.
        [ ] Seeded runs are identical.
    -->

    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Inter:wght@300;400;600&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a;
            color: #e2e8f0;
            overflow: hidden; 
        }

        .font-mono { font-family: 'JetBrains Mono', monospace; }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }

        .glass-panel {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.1);
        }

        /* 3D Canvas container */
        #canvas-container {
            position: absolute;
            top: 0; left: 0; width: 100vw; height: 100vh;
            z-index: 0;
        }

        /* UI Overlay Layer */
        #ui-layer {
            position: relative;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through to canvas where needed */
            height: 100vh;
            display: grid;
            grid-template-columns: 320px 1fr 350px;
            grid-template-rows: 60px 1fr 250px;
            gap: 1rem;
            padding: 1rem;
        }

        /* Enable pointer events on panels */
        .pointer-events-auto { pointer-events: auto; }
        
        .tab-active { border-bottom: 2px solid #10b981; color: #10b981; }
        .tab-inactive { color: #94a3b8; }
        
        /* Pulse animation for live status */
        @keyframes pulse-dot {
            0% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7); }
            70% { box-shadow: 0 0 0 6px rgba(16, 185, 129, 0); }
            100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }
        }
        .live-dot { animation: pulse-dot 2s infinite; }
    </style>
</head>
<body>

    <!-- 3D Layer -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div id="ui-layer">
        
        <!-- TOP LEFT: Header -->
        <div class="col-span-3 h-full flex items-center justify-between pointer-events-auto glass-panel rounded-xl px-6">
            <div class="flex items-center gap-3">
                <div class="w-3 h-3 bg-green-500 rounded-full live-dot"></div>
                <h1 class="text-xl font-bold tracking-tight">CRYPTO<span class="text-green-400">NET</span> SIMULATOR</h1>
            </div>
            
            <div class="flex gap-6 font-mono text-sm">
                <div>
                    <span class="text-gray-400 text-xs block">NETWORK HASH</span>
                    <span id="stat-nethash" class="text-blue-400 font-bold">0 PH/s</span>
                </div>
                <div>
                    <span class="text-gray-400 text-xs block">DIFFICULTY</span>
                    <span id="stat-diff" class="text-yellow-400 font-bold">1.00</span>
                </div>
                <div>
                    <span class="text-gray-400 text-xs block">COIN PRICE</span>
                    <span id="stat-price" class="text-green-400 font-bold">$40.00</span>
                </div>
                <div>
                    <span class="text-gray-400 text-xs block">BLOCK HEIGHT</span>
                    <span id="stat-height" class="text-white font-bold">0</span>
                </div>
            </div>

            <div class="flex gap-2">
                <button onclick="toggleHelp()" class="p-2 hover:bg-white/10 rounded-full transition" title="Help">
                    <svg class="w-5 h-5 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                </button>
            </div>
        </div>

        <!-- LEFT SIDEBAR: Controls & Views -->
        <div class="row-start-2 row-span-2 pointer-events-auto glass-panel rounded-xl flex flex-col overflow-hidden">
            <!-- View Switcher -->
            <div class="flex border-b border-gray-700">
                <button onclick="switchView('lobby')" id="tab-lobby" class="flex-1 py-3 text-xs font-bold uppercase hover:bg-white/5 transition tab-active">Lobby</button>
                <button onclick="switchView('network')" id="tab-network" class="flex-1 py-3 text-xs font-bold uppercase hover:bg-white/5 transition tab-inactive">Net</button>
                <button onclick="switchView('farm')" id="tab-farm" class="flex-1 py-3 text-xs font-bold uppercase hover:bg-white/5 transition tab-inactive">Farm</button>
                <button onclick="switchView('explorer')" id="tab-explorer" class="flex-1 py-3 text-xs font-bold uppercase hover:bg-white/5 transition tab-inactive">Blocks</button>
            </div>

            <!-- Scrollable Control Content -->
            <div class="flex-1 overflow-y-auto p-4 space-y-6 scrollbar-custom">
                
                <!-- Playback Controls -->
                <div class="bg-gray-800/50 p-3 rounded-lg border border-gray-700">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-xs font-bold text-gray-400">SIMULATION CONTROL</span>
                        <span id="sim-speed-disp" class="text-xs text-green-400 font-mono">x1</span>
                    </div>
                    <div class="flex gap-2 mb-2">
                        <button id="btn-play" onclick="toggleSim()" class="flex-1 bg-green-600 hover:bg-green-500 text-white font-bold py-1 px-2 rounded text-sm transition">Start</button>
                        <button onclick="resetSim()" class="bg-red-900/50 hover:bg-red-900 text-red-200 border border-red-800 py-1 px-3 rounded text-sm transition">Reset</button>
                    </div>
                    <input type="range" id="speed-slider" min="0" max="3" step="1" value="0" class="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    <div class="flex justify-between text-[10px] text-gray-500 mt-1">
                        <span>x1</span><span>x10</span><span>x100</span><span>x1000</span>
                    </div>
                </div>

                <!-- My Miner Profile -->
                <div>
                    <h3 class="text-xs font-bold text-gray-400 mb-2 uppercase">My Mining Operation</h3>
                    <div class="bg-gray-800/50 p-3 rounded-lg border border-gray-700 space-y-3">
                        <div class="flex justify-between text-sm">
                            <span class="text-gray-400">Balance</span>
                            <span id="user-balance" class="font-mono text-green-400">0.0000 COIN</span>
                        </div>
                        <div class="flex justify-between text-sm">
                            <span class="text-gray-400">Hashrate</span>
                            <span id="user-hash" class="font-mono text-blue-400">400 MH/s</span>
                        </div>
                        <button onclick="upgradeUserRig()" class="w-full bg-blue-600 hover:bg-blue-500 text-white text-xs font-bold py-2 rounded transition">
                            Buy Rig (+100 MH/s) <span id="upgrade-cost" class="font-mono opacity-70">$2,000</span>
                        </button>
                    </div>
                </div>

                <!-- Strategy -->
                <div>
                    <h3 class="text-xs font-bold text-gray-400 mb-2 uppercase">Configuration</h3>
                    <div class="space-y-3">
                        <div>
                            <label class="text-xs text-gray-500">Seed (Deterministic)</label>
                            <div class="flex gap-1">
                                <input id="seed-input" type="text" value="satoshi" class="w-full bg-gray-800 border border-gray-600 rounded px-2 py-1 text-xs font-mono">
                                <button onclick="randomizeSeed()" class="bg-gray-700 px-2 rounded hover:bg-gray-600">ðŸŽ²</button>
                            </div>
                        </div>
                        <div class="flex items-center justify-between">
                            <span class="text-xs text-gray-400">Bot Auto-Upgrade</span>
                            <input type="checkbox" id="bot-mode" checked class="accent-green-500">
                        </div>
                         <div class="flex items-center justify-between">
                            <span class="text-xs text-gray-400">Price Volatility</span>
                            <input type="checkbox" id="volatility-mode" checked class="accent-green-500">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- RIGHT SIDEBAR: Leaderboard & Logs -->
        <div class="col-start-3 row-start-2 row-span-2 pointer-events-auto glass-panel rounded-xl flex flex-col overflow-hidden">
            <div class="p-3 border-b border-gray-700 bg-gray-800/50">
                <h3 class="text-xs font-bold text-gray-300 uppercase">Top Miners (Profit)</h3>
            </div>
            <div class="flex-1 overflow-y-auto scrollbar-custom">
                <table class="w-full text-left text-xs">
                    <thead class="bg-gray-800 text-gray-500 font-mono sticky top-0">
                        <tr>
                            <th class="p-2">#</th>
                            <th class="p-2">Name</th>
                            <th class="p-2 text-right">Hash</th>
                            <th class="p-2 text-right">Net $</th>
                        </tr>
                    </thead>
                    <tbody id="leaderboard-body" class="font-mono text-gray-300">
                        <!-- Populated by JS -->
                    </tbody>
                </table>
            </div>
            
            <div class="h-1/3 border-t border-gray-700 flex flex-col bg-black/20">
                <div class="p-2 flex justify-between items-center bg-gray-800/50">
                    <span class="text-[10px] font-bold text-gray-400 uppercase">Event Log</span>
                    <button onclick="exportCSV()" class="text-[10px] text-blue-400 hover:text-white">Export CSV</button>
                </div>
                <div id="event-log" class="flex-1 overflow-y-auto p-2 font-mono text-[10px] space-y-1 text-gray-400">
                    <div class="text-gray-600 italic">Network initialized...</div>
                </div>
            </div>
        </div>

        <!-- BOTTOM CENTER: Analytics -->
        <div class="col-start-2 row-start-3 pointer-events-auto glass-panel rounded-xl p-4 flex flex-col">
            <h3 class="text-xs font-bold text-gray-400 uppercase mb-2">Real-time Metrics</h3>
            <div class="flex-1 relative w-full h-full">
                <canvas id="mainChart"></canvas>
            </div>
        </div>

    </div>

    <!-- Help Modal -->
    <div id="help-modal" class="fixed inset-0 z-50 bg-black/80 hidden flex items-center justify-center backdrop-blur-sm pointer-events-auto">
        <div class="bg-gray-800 rounded-xl max-w-2xl w-full border border-gray-700 shadow-2xl p-6">
            <h2 class="text-2xl font-bold text-green-400 mb-4">How it Works</h2>
            <div class="space-y-4 text-sm text-gray-300 overflow-y-auto max-h-[60vh]">
                <p>This simulation models a Proof-of-Work blockchain network using a Poisson process for block discovery.</p>
                <ul class="list-disc pl-5 space-y-2">
                    <li><strong>Mining Math:</strong> Probability of finding a block $P = 1 - e^{-\lambda t}$ where $\lambda = \frac{\text{Hashrate}}{\text{Difficulty} \times 2^{32}}$.</li>
                    <li><strong>Network Latency:</strong> When a block is found, it propagates through the network graph. Nodes act as relays. Latency causes "Orphan Blocks" (red blocks in Explorer) if two miners find blocks simultaneously.</li>
                    <li><strong>Visuals:</strong> 
                        <br>- <strong>Lobby:</strong> Miners gathering.
                        <br>- <strong>Net:</strong> Topology graph. Light packets = blocks/txs.
                        <br>- <strong>Farm:</strong> Your rig setup.
                        <br>- <strong>Explorer:</strong> The blockchain ledger.
                    </li>
                    <li><strong>Economy:</strong> Coin price follows a Geometric Brownian Motion model. Electricity cost reduces net profit.</li>
                </ul>
            </div>
            <button onclick="toggleHelp()" class="mt-6 w-full bg-gray-700 hover:bg-gray-600 text-white py-2 rounded">Close</button>
        </div>
    </div>

    <script>
        /**
         * CORE ARCHITECTURE
         * 1. CONFIG & UTILS: Constants and Helper functions (PRNG).
         * 2. STATE: The source of truth for the simulation.
         * 3. ENGINE: The logic loop (Math, Economy, Network Propagation).
         * 4. VISUALIZER: Three.js management (Scenes, Objects, Animation).
         * 5. UI: DOM updates.
         */

        // --- 1. CONFIG & UTILS ---
        const CONFIG = {
            baseDifficulty: 100000, 
            blockTargetTime: 10, // Seconds (Simulated)
            halvingInterval: 50, // Blocks
            initialPrice: 40,
            initialMiners: 120,
            rigCost: 2000,
            rigHash: 100, // MH/s
            powerCost: 0.12, // $/kWh
            wattsPerRig: 200,
            speeds: [1, 10, 100, 1000]
        };

        class SeededRNG {
            constructor(seed) {
                this.seed = this.hash(seed);
            }
            hash(str) {
                let h = 0x811c9dc5;
                for (let i = 0; i < str.length; i++) {
                    h ^= str.charCodeAt(i);
                    h = Math.imul(h, 0x01000193);
                }
                return h >>> 0;
            }
            // Mulberry32
            next() {
                let t = this.seed += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
            range(min, max) { return min + this.next() * (max - min); }
        }

        let rng = new SeededRNG("satoshi");

        // --- 2. STATE ---
        const State = {
            running: false,
            speedIdx: 0,
            time: 0, // Simulated seconds
            lastTickReal: 0,
            
            miners: [],
            blocks: [],
            orphans: [],
            mempool: 0,
            
            network: {
                totalHash: 0,
                difficulty: CONFIG.baseDifficulty,
                price: CONFIG.initialPrice,
                lastBlockTime: 0
            },
            
            userMinerId: null,
            logs: [],
            
            // Events queue for network propagation { time, type, sourceId, data }
            eventQueue: []
        };

        class Miner {
            constructor(id, isBot = true, hash = 100) {
                this.id = id;
                this.name = isBot ? `Bot-${id.toString().padStart(3,'0')}` : "YOU";
                this.isBot = isBot;
                this.hashRate = hash; // MH/s
                this.rigs = Math.max(1, Math.floor(hash / 100));
                this.balance = 0;
                this.profit = 0;
                this.cost = 0;
                this.color = isBot ? Math.random() * 0xffffff : 0x10b981;
                // Network graph position (simulation only)
                this.x = (rng.next() - 0.5) * 100;
                this.y = (rng.next() - 0.5) * 100;
                this.z = (rng.next() - 0.5) * 100;
                this.connections = []; // Neighbors
            }
        }

        class Block {
            constructor(height, hash, parentHash, minerId, timestamp) {
                this.height = height;
                this.hash = hash;
                this.parentHash = parentHash;
                this.minerId = minerId;
                this.timestamp = timestamp;
                this.isOrphan = false;
            }
        }

        // --- 3. ENGINE ---
        const Engine = {
            init() {
                State.miners = [];
                State.blocks = [];
                State.orphans = [];
                State.eventQueue = [];
                State.time = 0;
                State.network.difficulty = CONFIG.baseDifficulty;
                State.network.price = CONFIG.initialPrice;

                // Create User
                const user = new Miner('user', false, 400);
                State.userMinerId = 'user';
                State.miners.push(user);

                // Create Bots
                for(let i=0; i < CONFIG.initialMiners; i++) {
                    // Random hash distribution (Pareto-ish)
                    const tier = rng.next();
                    let hash = 100;
                    if(tier > 0.95) hash = 5000; // Whale
                    else if(tier > 0.8) hash = 1000; // Pool
                    else hash = 100 + Math.floor(rng.next() * 400);
                    
                    State.miners.push(new Miner(i, true, hash));
                }

                // Build Network Topology (Simple Random Graph)
                State.miners.forEach(m1 => {
                    const connections = Math.floor(rng.range(2, 5));
                    for(let i=0; i<connections; i++) {
                        const m2 = State.miners[Math.floor(rng.next() * State.miners.length)];
                        if(m1 !== m2 && !m1.connections.includes(m2.id)) {
                            m1.connections.push(m2.id);
                            m2.connections.push(m1.id);
                        }
                    }
                });

                // Genesis Block
                State.blocks.push(new Block(0, "0000genesis", "0", "system", 0));
                
                UI.log("Genesis block created.");
            },

            tick(deltaReal) {
                if (!State.running) return;

                const dt = deltaReal * CONFIG.speeds[State.speedIdx];
                State.time += dt;

                // 1. Calculate Network Hash
                State.network.totalHash = State.miners.reduce((acc, m) => acc + m.hashRate, 0);

                // 2. Mining Loop (Poisson Process)
                State.miners.forEach(miner => {
                    // Cost Calculation
                    const kwh = (miner.rigs * CONFIG.wattsPerRig / 1000) * (dt / 3600);
                    const cost = kwh * CONFIG.powerCost;
                    miner.cost += cost;
                    miner.profit -= cost; // Temporary, revenue added on block found

                    // Mining Probability P = 1 - e^(-lambda * t)
                    // Lambda = Hash / (Difficulty * 2^32)
                    // We scale Difficulty for simulation fun so we don't need real 2^32
                    // Sim Difficulty 1.0 ~= 100MH/s finds block in 10 sec
                    const effectiveDiff = State.network.difficulty * 1000000; 
                    const lambda = (miner.hashRate * 1000000) / effectiveDiff;
                    const prob = 1 - Math.exp(-lambda * dt);

                    if (rng.next() < prob) {
                        Engine.mineBlock(miner);
                    }
                });

                // 3. Economy (Brownian Motion)
                const vol = document.getElementById('volatility-mode').checked ? 0.002 : 0;
                const change = (rng.next() - 0.5) * vol * Math.sqrt(dt);
                State.network.price = Math.max(0.01, State.network.price * (1 + change));

                // 4. Bot Strategy
                if (document.getElementById('bot-mode').checked && Math.floor(State.time) % 60 === 0) {
                     State.miners.forEach(m => {
                         if(m.isBot && m.profit > CONFIG.rigCost * 1.5) {
                             m.profit -= CONFIG.rigCost;
                             m.rigs++;
                             m.hashRate += CONFIG.rigHash;
                             // Visual update handled by visualizer polling
                         }
                     });
                }
            },

            mineBlock(miner) {
                const lastBlock = State.blocks[State.blocks.length - 1];
                const newHeight = lastBlock.height + 1;
                
                // Simulate Propogation Delay causing Orphans
                // If a block was found very recently (e.g. within 0.5 sim seconds), conflict!
                const timeSinceLast = State.time - State.network.lastBlockTime;
                
                if (timeSinceLast < 0.5 * CONFIG.speeds[State.speedIdx]) {
                    // Orphan Event
                    const orphan = new Block(newHeight, "0000orphan" + Math.floor(rng.next()*1000), lastBlock.hash, miner.id, State.time);
                    orphan.isOrphan = true;
                    State.orphans.push(orphan);
                    UI.log(`ORPHAN detected! Miner ${miner.name} lost race.`, 'warn');
                    Visualizer.triggerOrphan(miner);
                    return;
                }

                // Valid Block
                const reward = 50 * Math.pow(0.5, Math.floor(newHeight / CONFIG.halvingInterval));
                const revenue = reward * State.network.price;
                
                miner.balance += reward;
                miner.profit += revenue;

                const newBlock = new Block(newHeight, "0000" + Math.floor(rng.next()*100000), lastBlock.hash, miner.id, State.time);
                State.blocks.push(newBlock);
                State.network.lastBlockTime = State.time;

                // Difficulty Retarget (Simple Moving Average)
                if (newHeight % 10 === 0) {
                    const tenBlocksAgo = State.blocks[State.blocks.length - 11];
                    if (tenBlocksAgo) {
                        const actualTime = State.time - tenBlocksAgo.timestamp;
                        const targetTime = CONFIG.blockTargetTime * 10;
                        const ratio = targetTime / actualTime;
                        State.network.difficulty *= ratio;
                        // Clamp
                        State.network.difficulty = Math.max(1000, State.network.difficulty);
                    }
                }

                UI.log(`Block #${newHeight} found by ${miner.name}! Reward: ${revenue.toFixed(2)}`, 'success');
                Visualizer.triggerBlock(miner, newBlock);
            }
        };

        // --- 4. VISUALIZER (Three.js) ---
        const Visualizer = {
            scene: null, camera: null, renderer: null, controls: null,
            view: 'lobby', // lobby, network, farm, explorer
            objects: {
                miners: [], // Meshes
                connections: [],
                blocks: [],
                avatars: []
            },
            materials: {},

            init() {
                const container = document.getElementById('canvas-container');
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0f172a);
                this.scene.fog = new THREE.FogExp2(0x0f172a, 0.005);

                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 30, 60);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                container.appendChild(this.renderer.domElement);

                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;

                // Lights
                const ambient = new THREE.AmbientLight(0x404040, 2);
                this.scene.add(ambient);
                const dirLight = new THREE.DirectionalLight(0xffffff, 1);
                dirLight.position.set(10, 50, 10);
                dirLight.castShadow = true;
                this.scene.add(dirLight);

                // Init Views
                this.initMaterials();
                this.setupLobby();

                window.addEventListener('resize', () => this.onResize());
            },

            initMaterials() {
                this.materials.node = new THREE.MeshStandardMaterial({ color: 0x3b82f6, emissive: 0x1d4ed8, emissiveIntensity: 0.2 });
                this.materials.nodeUser = new THREE.MeshStandardMaterial({ color: 0x10b981, emissive: 0x059669, emissiveIntensity: 0.5 });
                this.materials.line = new THREE.LineBasicMaterial({ color: 0x1e293b, transparent: true, opacity: 0.3 });
                this.materials.block = new THREE.MeshStandardMaterial({ color: 0xf59e0b, roughness: 0.1, metalness: 0.8 });
                this.materials.orphan = new THREE.MeshStandardMaterial({ color: 0xef4444, wireframe: true });
            },

            clearScene() {
                // Remove everything except lights
                this.scene.children = this.scene.children.filter(c => c.isLight);
            },

            // --- VIEW SETUPS ---

            setupLobby() {
                this.view = 'lobby';
                this.clearScene();
                this.controls.maxDistance = 60;
                
                // Floor
                const floor = new THREE.Mesh(
                    new THREE.CircleGeometry(50, 64),
                    new THREE.MeshStandardMaterial({ color: 0x1e293b, roughness: 0.8 })
                );
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                this.scene.add(floor);

                // Central Pool (literal pool)
                const poolGeo = new THREE.TorusGeometry(10, 1, 16, 100);
                const pool = new THREE.Mesh(poolGeo, new THREE.MeshStandardMaterial({ color: 0x10b981, emissive: 0x10b981, emissiveIntensity: 0.5 }));
                pool.rotation.x = -Math.PI / 2;
                pool.scale.set(1, 1, 0.2);
                this.scene.add(pool);

                // Miner Avatars (Instanced)
                const count = State.miners.length;
                // FIXED: Changed CapsuleGeometry (unavailable in r128) to CylinderGeometry
                const geo = new THREE.CylinderGeometry(0.5, 0.5, 1, 8); 
                const mat = new THREE.MeshStandardMaterial({ color: 0x64748b });
                const mesh = new THREE.InstancedMesh(geo, mat, count);
                mesh.castShadow = true;
                
                const dummy = new THREE.Object3D();
                State.miners.forEach((m, i) => {
                    const angle = Math.random() * Math.PI * 2;
                    const r = 12 + Math.random() * 20;
                    dummy.position.set(Math.cos(angle)*r, 1, Math.sin(angle)*r);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                    
                    // Store velocity for animation
                    m.userData = { 
                        angle, r, 
                        speed: 0.002 + Math.random() * 0.005 
                    };
                });
                
                this.objects.avatars = mesh;
                this.scene.add(mesh);
                
                this.camera.position.set(0, 20, 40);
                this.camera.lookAt(0,0,0);
            },

            setupNetwork() {
                this.view = 'network';
                this.clearScene();
                this.controls.maxDistance = 200;

                // Miner Nodes
                const count = State.miners.length;
                const geo = new THREE.SphereGeometry(0.5, 16, 16);
                const mesh = new THREE.InstancedMesh(geo, this.materials.node, count);
                
                const dummy = new THREE.Object3D();
                State.miners.forEach((m, i) => {
                    dummy.position.set(m.x, m.y, m.z);
                    // Scale based on hashrate
                    const s = 1 + Math.log10(m.hashRate / 50);
                    dummy.scale.set(s,s,s);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                    
                    // If user, color differently (hacky via instancing color attribute if needed, simple here)
                    if(!m.isBot) mesh.setColorAt(i, new THREE.Color(0x10b981));
                });
                mesh.instanceMatrix.needsUpdate = true;
                if(mesh.instanceColor) mesh.instanceColor.needsUpdate = true;
                
                this.objects.miners = mesh;
                this.scene.add(mesh);

                // Links
                const points = [];
                State.miners.forEach(m1 => {
                    m1.connections.forEach(id2 => {
                        const m2 = State.miners.find(m => m.id == id2);
                        if(m2 && m1.id < m2.id) { // Avoid duplicates
                            points.push(new THREE.Vector3(m1.x, m1.y, m1.z));
                            points.push(new THREE.Vector3(m2.x, m2.y, m2.z));
                        }
                    });
                });
                const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
                const lines = new THREE.LineSegments(lineGeo, this.materials.line);
                this.scene.add(lines);

                this.camera.position.set(0, 0, 150);
            },

            setupFarm() {
                this.view = 'farm';
                this.clearScene();
                
                // Floor
                const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({ color: 0x0f172a }));
                floor.rotation.x = -Math.PI / 2;
                this.scene.add(floor);

                // Racks
                const user = State.miners.find(m => m.id === 'user');
                const rigs = user.rigs;
                const rigGeo = new THREE.BoxGeometry(2, 1, 3);
                const rigMat = new THREE.MeshStandardMaterial({ color: 0x334155, metalness: 0.6, roughness: 0.4 });
                
                const rows = Math.ceil(Math.sqrt(rigs));
                const cols = Math.ceil(rigs / rows);

                for(let i=0; i<rigs; i++) {
                    const r = Math.floor(i / cols);
                    const c = i % cols;
                    const mesh = new THREE.Mesh(rigGeo, rigMat);
                    mesh.position.set((c - cols/2)*4, 1, (r - rows/2)*5);
                    
                    // LED
                    const led = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({ color: 0x10b981 }));
                    led.position.set(0.8, 0.4, 1.51);
                    mesh.add(led);
                    
                    // Pulse animation helper
                    mesh.userData = { led, offset: Math.random() * 10 };
                    
                    this.scene.add(mesh);
                }

                this.camera.position.set(0, 20, 20);
                this.camera.lookAt(0,0,0);
            },

            setupExplorer() {
                this.view = 'explorer';
                this.clearScene();
                
                // Visualize last 50 blocks
                const blocks = State.blocks.slice(-50);
                blocks.forEach((b, i) => {
                    const geo = new THREE.BoxGeometry(2, 2, 2);
                    const mesh = new THREE.Mesh(geo, this.materials.block);
                    mesh.position.set(i * 3 - (blocks.length * 1.5), 0, 0);
                    
                    // Height label
                    // (Simple representation, text sprites are complex for single-file, omitting for perf)
                    
                    this.scene.add(mesh);
                });

                // Visualize Orphans slightly offset
                State.orphans.slice(-10).forEach((b, i) => {
                     const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 1.5), this.materials.orphan);
                     mesh.position.set(0, 3, 0); // Need mapping to parent, simplified for now
                     // To make it look good without complex parent lookup in render loop, just scatter them
                     mesh.position.set(Math.random() * 50 - 25, 3, Math.random() * 10 - 5);
                     this.scene.add(mesh);
                });

                this.camera.position.set(0, 10, 30);
                this.camera.lookAt(0,0,0);
            },

            // --- ANIMATION & EVENTS ---

            render() {
                requestAnimationFrame(() => this.render());
                this.controls.update();

                const time = Date.now() * 0.001;

                if (this.view === 'lobby') {
                    // Animate Avatars
                    const mesh = this.objects.avatars;
                    const dummy = new THREE.Object3D();
                    
                    State.miners.forEach((m, i) => {
                        if (m.userData) {
                            m.userData.angle += m.userData.speed;
                            dummy.position.set(
                                Math.cos(m.userData.angle) * m.userData.r,
                                1 + Math.sin(time * 5 + i)*0.1, // Bobbing
                                Math.sin(m.userData.angle) * m.userData.r
                            );
                            dummy.lookAt(0, 1, 0);
                            dummy.updateMatrix();
                            mesh.setMatrixAt(i, dummy.matrix);
                        }
                    });
                    mesh.instanceMatrix.needsUpdate = true;
                }
                else if (this.view === 'farm') {
                    this.scene.children.forEach(child => {
                        if(child.userData && child.userData.led) {
                            const intensity = (Math.sin(time * 5 + child.userData.offset) + 1) / 2;
                            child.userData.led.material.color.setHSL(0.4, 1, 0.2 + intensity * 0.5);
                        }
                    });
                }
                else if (this.view === 'network') {
                    // Rotate network slowly
                    this.objects.miners.rotation.y = time * 0.05;
                    // Pulse User Node
                    // (Requires more complex instance color buffer updates, skipping for brevity)
                }

                this.renderer.render(this.scene, this.camera);
            },

            triggerBlock(miner, block) {
                // Flash effect based on view
                if (this.view === 'network') {
                    // Create a temporary expanding sphere at miner location
                    const geo = new THREE.SphereGeometry(1, 16, 16);
                    const mat = new THREE.MeshBasicMaterial({ color: 0xf59e0b, transparent: true, opacity: 0.8 });
                    const mesh = new THREE.Mesh(geo, mat);
                    
                    // Find miner pos (reverse rotation logic needed or just place in local space of container)
                    // Simplified: Just spawn at center for impact if rotation is complex, 
                    // or transform coordinates.
                    mesh.position.set(miner.x, miner.y, miner.z);
                    
                    // Attach to the rotating group or scene
                    // Since miners mesh rotates, we should add this to a parent group. 
                    // For now, add to scene but it won't rotate perfectly with nodes. 
                    // Visual flair only.
                    this.scene.add(mesh);

                    // Animate scale up and fade out
                    let s = 1;
                    const anim = () => {
                        s += 0.5;
                        mesh.scale.set(s,s,s);
                        mesh.material.opacity -= 0.02;
                        if(mesh.material.opacity > 0) requestAnimationFrame(anim);
                        else this.scene.remove(mesh);
                    };
                    anim();
                } else if (this.view === 'explorer') {
                    this.setupExplorer(); // Refresh view
                }
            },

            triggerOrphan(miner) {
                // Red flash
            },

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        };

        // --- 5. UI MANAGER ---
        const UI = {
            chart: null,
            
            init() {
                this.initChart();
                this.updateLeaderboard();
                
                // Key Listeners
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') toggleSim();
                    if (['Digit1','Digit2','Digit3','Digit4'].includes(e.code)) {
                        const idx = parseInt(e.key) - 1;
                        document.getElementById('speed-slider').value = idx;
                        updateSpeed(idx);
                    }
                    if (e.code === 'KeyV') {
                        const views = ['lobby', 'network', 'farm', 'explorer'];
                        const curr = views.indexOf(Visualizer.view);
                        switchView(views[(curr + 1) % 4]);
                    }
                });

                document.getElementById('speed-slider').addEventListener('input', (e) => {
                    updateSpeed(parseInt(e.target.value));
                });
            },

            initChart() {
                const ctx = document.getElementById('mainChart').getContext('2d');
                Chart.defaults.color = '#94a3b8';
                this.chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Net Worth ($)',
                            data: [],
                            borderColor: '#10b981',
                            tension: 0.4,
                            pointRadius: 0
                        }, {
                            label: 'Coin Price ($)',
                            data: [],
                            borderColor: '#3b82f6',
                            tension: 0.4,
                            pointRadius: 0,
                            yAxisID: 'y1'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        scales: {
                            x: { display: false },
                            y: { grid: { color: '#334155' } },
                            y1: { position: 'right', grid: { drawOnChartArea: false } }
                        },
                        plugins: { legend: { display: true } }
                    }
                });
            },

            update() {
                // DOM Text Updates
                document.getElementById('stat-nethash').innerText = formatHash(State.network.totalHash);
                document.getElementById('stat-diff').innerText = (State.network.difficulty / 1000).toFixed(2) + 'k';
                document.getElementById('stat-price').innerText = '$' + State.network.price.toFixed(2);
                document.getElementById('stat-height').innerText = State.blocks.length;

                const user = State.miners.find(m => m.id === State.userMinerId);
                if (user) {
                    document.getElementById('user-balance').innerText = user.balance.toFixed(4) + ' COIN';
                    document.getElementById('user-hash').innerText = user.hashRate + ' MH/s';
                    
                    // Color based on affordance
                    const cost = 2000; // Fixed for now
                    const btn = document.getElementById('upgrade-cost');
                    if(user.profit > cost) btn.classList.add('text-green-400');
                    else btn.classList.remove('text-green-400');
                }

                // Throttle Chart/Table Updates
                if (Math.floor(State.time) % 5 === 0) {
                    this.updateLeaderboard();
                    this.updateChart();
                }
            },

            updateLeaderboard() {
                const sorted = [...State.miners].sort((a,b) => b.profit - a.profit).slice(0, 15);
                const html = sorted.map((m, i) => `
                    <tr class="hover:bg-white/5 transition ${m.id === 'user' ? 'bg-green-900/30' : ''}">
                        <td class="p-2 text-gray-500">${i+1}</td>
                        <td class="p-2 flex items-center gap-2">
                            <div class="w-2 h-2 rounded-full" style="background-color: #${m.color.toString(16).padStart(6,'0')}"></div>
                            ${m.name}
                        </td>
                        <td class="p-2 text-right text-gray-400">${formatHash(m.hashRate)}</td>
                        <td class="p-2 text-right ${m.profit >= 0 ? 'text-green-400' : 'text-red-400'}">$${m.profit.toFixed(0)}</td>
                    </tr>
                `).join('');
                document.getElementById('leaderboard-body').innerHTML = html;
            },

            updateChart() {
                const user = State.miners.find(m => m.id === State.userMinerId);
                const len = this.chart.data.labels.length;
                if (len > 50) {
                    this.chart.data.labels.shift();
                    this.chart.data.datasets[0].data.shift();
                    this.chart.data.datasets[1].data.shift();
                }
                this.chart.data.labels.push(Math.floor(State.time));
                this.chart.data.datasets[0].data.push(user.profit);
                this.chart.data.datasets[1].data.push(State.network.price);
                this.chart.update();
            },

            log(msg, type='info') {
                const colors = { info: 'text-gray-400', success: 'text-green-400', warn: 'text-yellow-400' };
                const div = document.createElement('div');
                div.className = colors[type];
                div.innerHTML = `<span class="opacity-50">[${Math.floor(State.time)}s]</span> ${msg}`;
                const container = document.getElementById('event-log');
                container.prepend(div);
                if (container.children.length > 50) container.lastChild.remove();
                
                State.logs.push({ time: State.time, msg, type });
            }
        };

        function formatHash(h) {
            if (h > 1000000) return (h/1000000).toFixed(2) + ' TH/s';
            if (h > 1000) return (h/1000).toFixed(2) + ' GH/s';
            return h.toFixed(0) + ' MH/s';
        }

        // --- 6. CONTROLLERS (Global) ---

        function toggleSim() {
            State.running = !State.running;
            document.getElementById('btn-play').innerText = State.running ? "Pause" : "Resume";
            document.getElementById('btn-play').classList.toggle('bg-green-600');
            document.getElementById('btn-play').classList.toggle('bg-yellow-600');
            State.lastTickReal = Date.now();
        }

        function resetSim() {
            State.running = false;
            initSim();
            // Reset UI
            document.getElementById('btn-play').innerText = "Start";
            document.getElementById('btn-play').className = "flex-1 bg-green-600 hover:bg-green-500 text-white font-bold py-1 px-2 rounded text-sm transition";
        }

        function updateSpeed(idx) {
            State.speedIdx = idx;
            document.getElementById('sim-speed-disp').innerText = `x${CONFIG.speeds[idx]}`;
        }

        function switchView(viewName) {
            document.querySelectorAll('[id^="tab-"]').forEach(el => {
                el.classList.remove('tab-active');
                el.classList.add('tab-inactive');
            });
            document.getElementById(`tab-${viewName}`).classList.add('tab-active');
            document.getElementById(`tab-${viewName}`).classList.remove('tab-inactive');
            
            if(viewName === 'lobby') Visualizer.setupLobby();
            if(viewName === 'network') Visualizer.setupNetwork();
            if(viewName === 'farm') Visualizer.setupFarm();
            if(viewName === 'explorer') Visualizer.setupExplorer();
        }

        function upgradeUserRig() {
            const user = State.miners.find(m => m.id === 'user');
            // Allow buying into debt for gameplay flow
            user.profit -= CONFIG.rigCost;
            user.rigs++;
            user.hashRate += CONFIG.rigHash;
            UI.log("Purchased new rig +100MH/s", "info");
            
            if(Visualizer.view === 'farm') Visualizer.setupFarm(); // Refresh view
            if(Visualizer.view === 'network') Visualizer.setupNetwork(); // Refresh node scale
        }

        function randomizeSeed() {
            const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
            let str = '';
            for(let i=0; i<8; i++) str += chars[Math.floor(Math.random() * chars.length)];
            document.getElementById('seed-input').value = str;
            resetSim();
        }

        function exportCSV() {
            let csv = "Time,Message,Type\n";
            State.logs.forEach(l => {
                csv += `${l.time.toFixed(2)},"${l.msg}",${l.type}\n`;
            });
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `mining_sim_${document.getElementById('seed-input').value}.csv`;
            a.click();
        }

        function toggleHelp() {
            const el = document.getElementById('help-modal');
            el.classList.toggle('hidden');
        }

        function initSim() {
            const seed = document.getElementById('seed-input').value;
            rng = new SeededRNG(seed);
            Engine.init();
            UI.init();
            
            if (!Visualizer.scene) Visualizer.init();
            else Visualizer.setupLobby(); // Reset view
            
            State.lastTickReal = Date.now();
        }

        // --- MAIN LOOP ---
        function loop() {
            requestAnimationFrame(loop);
            const now = Date.now();
            const delta = (now - State.lastTickReal) / 1000;
            State.lastTickReal = now;
            
            if(State.running) {
                Engine.tick(delta);
                UI.update();
            }
        }

        // Start
        window.onload = () => {
            initSim();
            Visualizer.render(); // Start 3D Loop
            loop(); // Start Logic Loop
        };

    </script>
</body>
</html>
